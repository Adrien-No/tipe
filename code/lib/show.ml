(* (\* - Taille variable en fonction du poid des arêtes. *\) *)

(* open Graphics *)
(* open Type *)

(* let rayon_sommet = 3 *)
(* (\* on décale le max et le min car sinon avec un sommet sur la bordure, il déborde dans un sens. *\) *)
(* let couleur_sens_direct = 0x00FF00 (\*green*\) *)
(* let couleur_sens_retour = 0x0000FF (\*blue*\) *)
(* let decalage_double_sens = 3 *)

(* let dimensions_sommets (g:graph) : (float*float)*(float*float) = *)
(*   let min_x = Array.fold_left min max_float (Array.map (fun (x:intersection) -> x.x) g.sommets) *)
(*   and max_x = Array.fold_left max 0. (Array.map (fun (x:intersection) -> x.x) g.sommets) (\* -. 2.*.(float_of_int rayon_sommet) *\) *)
(*   and min_y = Array.fold_left min max_float (Array.map (fun (x:intersection) -> x.y) g.sommets) *)
(*   and max_y = Array.fold_left max 0. (Array.map (fun (x:intersection) -> x.y) g.sommets) (\* -. 2.*.(float_of_int rayon_sommet)  *\)in *)
(*   (\* Printf.printf "min : (%f,%f) | max : (%f,%f)\n" min_x min_y max_x max_y; *\) *)
(*   (min_x,min_y),(max_x,max_y) *)

(* let compute_new_coordinate (s:intersection) ((x_graphics,y_graphics):int*int) (((x_sommet_min,y_sommet_min),(x_sommet_max,y_sommet_max)):(float*float)*(float*float)) : int*int = *)
(*   (\* Renvoie à partir des données nécessaire les coordonnées d'un sommet dans la fenêtre Graphics. *\) *)
(*   (float_of_int x_graphics) *. (s.x-.x_sommet_min) /. (x_sommet_max-.x_sommet_min) |> int_of_float, *)
(*   (float_of_int y_graphics) *. (s.y-.y_sommet_min) /. (y_sommet_max-.y_sommet_min) |> int_of_float *)

(* let get_graph_new_coordonates (g:graph) (x_graphics,y_graphics) dims_sommets : int_graph = *)
(*   let int_sommets = Array.map (fun s -> let x,y = compute_new_coordinate s (x_graphics,y_graphics) dims_sommets in begin Printf.printf "(%i,%i)\n" x y; {id=s.id;x=x;y=y} end) g.sommets in *)
(*   {sommets=int_sommets;id_sommets=g.id_sommets;ladj=g.ladj} *)

(* let draw_graph_loop (g:graph) _ : unit = *)
(*   (\* On pourra mettre dims_sommets en paramètre.*\) *)
(*   let dims_sommets = dimensions_sommets g in *)
(*   open_graph ""; *)
(*   let g = get_graph_new_coordonates g (current_x(),current_y()) dims_sommets in *)
(*   let draw_sommet (s:int_sommet) : unit = *)
(*     (\* Printf.printf "avant :(%f,%f)\n" s.x s.y; *\) *)

(*     (\* g.sommets.(Hashtbl.find g.id_sommets s.id).x <- x; *\) *)
(*     (\* g.sommets.(Hashtbl.find g.id_sommets s.id).y <- y; *\) *)
(*     (\* Printf.printf "point aux coordonées (%i,%i)\n" s.x s.y; *\) *)
(*     (\* plot x y *\) *)
(*     draw_circle s.x s.y rayon_sommet *)
(*   in *)
(*   let draw_edges() = *)
(*     let sens_retour = Array.make_matrix (Array.length g.sommets) (Array.length g.sommets) false in *)
(*     let draw_edge i_x route = *)
(*       (\* i_x : indice du sommet source *\) *)
(*       (\* i_y : indice du sommet destination *\) *)
(*       let i_y = route.cible in *)
(*       if not sens_retour.(i_x).(i_y) then *)
(*         begin *)
(*         set_color couleur_sens_direct; *)
(*         moveto g.sommets.(i_x).x (g.sommets.(i_x).y+decalage_double_sens); *)
(*         lineto g.sommets.(i_y).y (g.sommets.(i_y).y+decalage_double_sens); *)
(*         sens_retour.(i_x).(i_y) <- false *)
(*         end *)
(*       else *)
(*         begin *)
(*         set_color couleur_sens_retour; *)
(*         moveto g.sommets.(i_x).x (g.sommets.(i_x).y-decalage_double_sens); *)
(*         lineto g.sommets.(i_y).y (g.sommets.(i_y).y-decalage_double_sens) *)
(*         end *)
(*     in *)
(*     Array.iteri (fun i_x l -> List.iter (fun route -> draw_edge i_x route) l) g.ladj *)
(*   in *)
(*   (\* draw sommets *\) *)
(*   Array.iter draw_sommet g.sommets; *)
(*   (\* draw edges *\) *)
(*   draw_edges(); *)
(*   Printf.printf "(%i,%i)\n" (size_x()) (size_y()); *)
(*   (\* while true do () done *\) *)
(*   let _ = read_key() in () *)
